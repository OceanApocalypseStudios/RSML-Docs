{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Red Sea Markup Language Docs","text":"<p>Warning</p> <p>The documentation for RSML is a work in progress.</p> <p>Red Sea Markup Language is the powerful and robust fork of MF's CrossRoad Solution, a language designed to dynamically interpret different logic paths based on the local host OS and CPU architecture.</p> <p>RSML (short for Red Sea Markup Language) can currently be used in C# and Python, as well as in its own CLI.</p> <p>This documentation is licensed under the GFDL.</p> <p>Copyright \u00a9 2025  OceanApocalypseStudios</p> <p>Permission is granted to copy, distribute and/or modify this document under the terms of the GNU Free Documentation License, Version 1.3 or any later version published by the Free Software Foundation; with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.</p>"},{"location":"#why-use-red-sea-markup-language","title":"Why use Red Sea Markup Language?","text":"<ul> <li> <p> Made for logic, logically.</p> <p>RSML is logic-heavy and therefore, everything about it is logical and easy to understand and use. One could say everything about it makes sense.</p> <p> The Language</p> </li> <li> <p> Easily embeddable.</p> <p>RSML is, obviously, intended to be used programmatically. RSML's fresh and easy API allow for an excellent experience embedding RSML into your program.</p> <p> The API</p> </li> <li> <p> Directly in your Terminal.</p> <p>Heavy-logic shouldn't mean \"open your editor and start writing <code>if</code> clauses\". That's where RSML's handy CLI comes in. It's a great way to quickly evaluate RSML files, at a relatively less complex level, without having to jump into your editor and write code.</p> <p> The CLI</p> </li> <li> <p> Our love for Open Source.</p> <p>RSML is the creation of a software and indie-game studios (OceanApocalypseStudios) that loves open-source. We can assure it will be free and open-source forever. It's also licensed under the very permissive MIT License, which is more than great!</p> <p> The GitHub Repository</p> </li> </ul>"},{"location":"#useful-links","title":"Useful Links","text":"<p>To further enhance your experience with RSML, we offer a list of useful links in this journey through our logic-heavy markup language.</p> <ul> <li> <p> GitHub Repository</p> <p>The official repository for Red Sea Markup Language.</p> <p> Visit</p> </li> <li> <p> NuGet Package</p> <p>RSML for C# is the main way to use RSML, so the NuGet link is going to be one of your best bets for getting help, among other things, even if you're using RSML with a language other than C#.</p> <p> Visit</p> </li> <li> <p> RSML for Python</p> <p>RSML for Python was the first port of RSML to another programming language to exist.</p> <p> Visit the repository</p> </li> <li> <p> RSML's Documentation Repository.</p> <p>While it might seem a bit redundant (after all, you're already here), it's useful if you wish to build the documentation locally, that is, if you want a offline copy of it.</p> <p> Visit the repository</p> </li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<p>We really appreciate contributions - they help us focus on releasing faster and better.</p> <p>That being said, there are some rules and guidelines you must follow.</p> <ul> <li> <p> KISS: Keep it simple, stupid.</p> <p>Make sure your changes are understandable and do not affect the simplicity of the documentation negatively.</p> </li> <li> <p> Know your branches.</p> <p>Make changes to <code>main</code>, NEVER to <code>gh-pages</code>.</p> </li> <li> <p> If it ain't broken, don't redesign it.</p> <p>Unless the current theme/CSS feels wrong or is broken, don't change it. Seriously. Don't.</p> </li> <li> <p> Fixing typos is noble; flooding PRs with them is chaos.</p> <p>Typo squatting is perfectly fine and helpful, but don't make too many Pull Requests to fix typos in a row, as it causes unnecessary spam. The best alternative is to \"bundle\" several typo fixes in one PR.</p> </li> </ul>"},{"location":"contributing/#questions","title":"Questions","text":"<p>Sadly, OceanApocalypseStudios does not have a formal way of contact (yet). Therefore, I'll allow users with questions to use my public e-mail instead, but please only make use of it if the questions are really, really important. Thank you.</p> <p>E-mail: <code>real_mf366@yahoo.com</code></p>"},{"location":"api/","title":"RSML as an API","text":"<p>Tip</p> <p>It's recommended to know the actual language itself before learning how to use RSML programmatically.</p>"},{"location":"api/demos/","title":"API Usage Examples","text":""},{"location":"language/","title":"RSML as a Language","text":"<p>Required Skills</p> <p>RSML uses Regex during logic path evaluations, so it's recommended you have at least a basic knowledge of it.</p> <p>RSML uses MSBuild RIDs to identify operating systems and CPU architectures, so it might be worth learning those.</p>"},{"location":"language/#files","title":"Files","text":"<p>The official standard file extension for Red Sea Markup Language files is <code>.rsea</code>, to avoid it being confused with other languages that also use the RSML abbreviation.</p> <p>The <code>.rsml</code> file extension is also fine, but <code>.rsea</code> is preferred.</p>"},{"location":"language/#language-specification","title":"Language Specification","text":"<p>Non-standardized</p> <p>Red Sea is not a standardized language. For the sake of examplifying without getting too technical, we'll be using the official-25 standard in most of the documentation, as it's the closest to an official specification.</p> <p>Red Sea is quite a simple language, but the lack of an official specification means behavior may vary across developer's implementations.</p>"},{"location":"language/#static-core-functionality-standardized","title":"Static Core Functionality (Standardized )","text":""},{"location":"language/#extensible-functionality-partially-standardized","title":"Extensible Functionality (Partially Standardized )","text":""},{"location":"language/#implementation-specific-functionality-non-standardized","title":"Implementation-specific Functionality (Non-Standardized )","text":""},{"location":"language/#operators","title":"Operators","text":""},{"location":"language/#evaluation-process","title":"Evaluation Process","text":"Strictly markup <p>Despite the usage of wording such as \"return\" and \"interpret\", RSML is purely declarative - it can not execute, compile or transpile code.</p> <p>RSML is evaluated from start to finish, meaning that the very first logic path that matches will be used and the evaluation ends there. All the logic beyond that point is ignored completely.</p> Return operator <p>Only the primary operator (<code>-&gt;</code> in the <code>official-25</code> standard) triggers the return of a logic path's value. The other operators, unless explicitly defined to do such, will never stop the evaluation.</p>"},{"location":"language/#syntax","title":"Syntax","text":"<p>RSML's syntax is quite simple and accessible, as there are only 3 valid line syntaxes. This means RSML only considers three different syntaxes as valid ones.</p> <p>Each logic path must be in a different line.</p>"},{"location":"language/#logic-path","title":"Logic Path","text":"<p>A logic path is the \"interactive\" part of RSML - it's what one would evaluate.</p> <p>The syntax for this is quite simple.</p> <p>Things worth mentioning:</p> <ul> <li>The operator must be one of the 3 defined in the standard you're using (see Language Specification).</li> <li>The value must be enclosed in double quotes (<code>\"</code>).</li> </ul> Actual SyntaxExample 1Example 2Example 3Example 4 <pre><code>&lt;regex-expression&gt; &lt;operator&gt; &lt;value&gt;\n</code></pre> <pre><code>win.+ -&gt; \"This is a valid logic path syntax\" # (1)!\n</code></pre> <ol> <li>The line is valid, as long as the <code>-&gt;</code> operator is defined. This will match all hosts with the Windows operating system.</li> </ol> <pre><code>(arch|ubuntu|debian)-x\\d\\d || \"Linux is nice\" # (1)!\n</code></pre> <ol> <li>This will match Debian, Ubuntu and Arch Linux distributions, as long as the CPU architecture is <code>x86</code> based (<code>x86</code> or <code>x64</code>).</li> </ol> <pre><code>osx.* || \"An apple a day keeps the doctor away, I guess...\" # (1)!\n</code></pre> <ol> <li>Keep in mind return values must be enclosed in double quotes.</li> </ol> <pre><code>win.* -&gt; \"I can smell windows.h\" # (1)!\nosx.* || \"An apple a day keeps the doctor away, I guess...\" # (2)!\n.+-x64 -&gt; \"64-bits is standard nowadays\" # (3)!\n</code></pre> <ol> <li>In <code>official-25</code>, this operator returns the logic path's value and ends evaluation (only if there's a match of course).</li> <li>In <code>official-25</code>, this operator outputs the logic path's value and does NOT end evaluation (only if there's a match of course).</li> <li>If one is on 64-bit Windows, this line wouldn't have been reached since the first line would have been a match and would've returned a value.</li> </ol>"},{"location":"language/#special-actions","title":"Special Actions","text":"<p>Special Actions will be a matter of discussion later, but, as of right now, all you need to know is that their syntax is also quite simple.</p> Actual SyntaxExample 1Example 2Example 3 <pre><code>@&lt;special-action&gt; [&lt;argument&gt;] # (1)!\n</code></pre> <ol> <li>The argument is optional, being an empty string if not specified. The argument must not contain any spaces.</li> </ol> <pre><code>@EndAll # (1)!\n</code></pre> <ol> <li>This is the only built-in standardized special action available. It'll be discussed later.</li> </ol> <pre><code>@MyAwesomeAction SomeValue # (1)!\n</code></pre> <ol> <li><code>SomeValue</code> does not need to be enclosed in double quotes.</li> </ol> <pre><code>@@ technically valid # (1)!\n</code></pre> <ol> <li>This line is valid, as there's no limitation to action names. Since the argument contains spaces, RSML will only use the first part of the argument (<code>technically</code>) as the whole argument.</li> </ol>"},{"location":"language/#comments","title":"Comments","text":"<p>Comments are quite simple in RSML. If a <code>#</code> character is at the start of a line, that line is now a comment.</p> <p>However, every single line that's considered invalid is also a comment. Here are some examples with reasons as of why they're invalid.</p> Actual SyntaxExample 1Example 2Example 3Example 4 <pre><code># ... // (1)!\n</code></pre> <ol> <li>Worth mentioning that a <code>#</code> in any other location other than the start of a line is not a comment, unless the line is invalid.</li> </ol> <pre><code>some random text # (1)!\n</code></pre> <ol> <li>According to <code>official-25</code>, this line is invalid; therefore, a comment.</li> </ol> <pre><code>// wrong type of comment # (1)!\n</code></pre> <ol> <li>According to <code>official-25</code>, this line is invalid; therefore, a comment.</li> </ol> <pre><code># a comment // (1)!\n</code></pre> <ol> <li>This line is a comment.</li> </ol> <pre><code>win.+ || \"Valid line\" # (1)!\n</code></pre> <ol> <li>This line is valid; therefore, not a comment.</li> </ol>"}]}