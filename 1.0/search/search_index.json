{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#welcome-to-red-sea-markup-language-docs","title":"Welcome to Red Sea Markup Language Docs","text":"<p>Warning</p> <p>The documentation for RSML is a work in progress.</p> <p>Red Sea Markup Language is the powerful and robust fork of MF's CrossRoad Solution, a language designed to dynamically interpret different logic paths based on the local host OS and CPU architecture.</p> <p>RSML (short for Red Sea Markup Language) can currently be used in C# and Python, as well as in its own CLI.</p> <p>This documentation is licensed under the GFDL.</p> <p>Copyright \u00a9 2025  OceanApocalypseStudios</p> <p>Permission is granted to copy, distribute and/or modify this document under the terms of the GNU Free Documentation License, Version 1.3 or any later version published by the Free Software Foundation; with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.</p>"},{"location":"#why-use-red-sea-markup-language","title":"Why use Red Sea Markup Language?","text":"<ul> <li> <p> Made for logic, logically.</p> <p>RSML is logic-heavy and therefore, everything about it is logical and easy to understand and use. One could say everything about it makes sense.</p> <p> The Language</p> </li> <li> <p> Easily embeddable.</p> <p>RSML is, obviously, intended to be used programmatically. RSML's fresh and easy API allow for an excellent experience embedding RSML into your program.</p> <p> The API</p> </li> <li> <p> Directly in your Terminal.</p> <p>Heavy-logic shouldn't mean \"open your editor and start writing <code>if</code> clauses\". That's where RSML's handy CLI comes in. It's a great way to quickly evaluate RSML files, at a relatively less complex level, without having to jump into your editor and write code.</p> <p> The CLI</p> </li> <li> <p> Our love for Open Source.</p> <p>RSML is the creation of a software and indie-game studios (OceanApocalypseStudios) that loves open-source. We can assure it will be free and open-source forever. It's also licensed under the very permissive MIT License, which is more than great!</p> <p> The GitHub Repository</p> </li> </ul>"},{"location":"#useful-links","title":"Useful Links","text":"<p>To further enhance your experience with RSML, we offer a list of useful links in this journey through our logic-heavy markup language.</p> <ul> <li> <p> GitHub Repository</p> <p>The official repository for Red Sea Markup Language.</p> <p> Visit</p> </li> <li> <p> NuGet Package</p> <p>RSML for C# is the main way to use RSML, so the NuGet link is going to be one of your best bets for getting help, among other things, even if you're using RSML with a language other than C#.</p> <p> Visit</p> </li> <li> <p> RSML for Python</p> <p>RSML for Python was the first port of RSML to another programming language to exist.</p> <p> Visit the repository</p> </li> <li> <p> RSML's Documentation Repository.</p> <p>While it might seem a bit redundant (after all, you're already here), it's useful if you wish to build the documentation locally, that is, if you want a offline copy of it.</p> <p> Visit the repository</p> </li> </ul>"},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#contributing","title":"Contributing","text":"<p>We really appreciate contributions - they help us focus on releasing faster and better.</p> <p>That being said, there are some rules and guidelines you must follow.</p> <ul> <li> <p> KISS: Keep it simple, stupid.</p> <p>Make sure your changes are understandable and do not affect the simplicity of the documentation negatively.</p> </li> <li> <p> Know your branches.</p> <p>Make changes to <code>main</code>, NEVER to <code>gh-pages</code>.</p> </li> <li> <p> If it ain't broken, don't redesign it.</p> <p>Unless the current theme/CSS feels wrong or is broken, don't change it. Seriously. Don't.</p> </li> <li> <p> Fixing typos is noble; flooding PRs with them is chaos.</p> <p>Typo squatting is perfectly fine and helpful, but don't make too many Pull Requests to fix typos in a row, as it causes unnecessary spam. The best alternative is to \"bundle\" several typo fixes in one PR.</p> </li> </ul>"},{"location":"contributing/#questions","title":"Questions","text":"<p>Sadly, OceanApocalypseStudios does not have a formal way of contact (yet). Therefore, I'll allow users with questions to use my public e-mail instead, but please only make use of it if the questions are really, really important. Thank you.</p> <p>E-mail: <code>real_mf366@yahoo.com</code></p>"},{"location":"api/","title":"RSML as an API","text":""},{"location":"api/#rsml-as-an-api","title":"RSML as an API","text":"<p>Tip</p> <p>It's recommended to know the actual language itself before learning how to use RSML programmatically.</p>"},{"location":"api/demos/","title":"Usage Demos","text":""},{"location":"api/demos/#api-usage-examples","title":"API Usage Examples","text":""},{"location":"language/","title":"RSML as a Language","text":""},{"location":"language/#rsml-as-a-language","title":"RSML as a Language","text":"Note <p>To make RSML easier to understand for beginners, this page starts with the \"easiest\" details of the language.</p>"},{"location":"language/#files","title":"Files","text":"<p>The official standard file extension for Red Sea Markup Language files is <code>.rsea</code>, to avoid it being confused with other languages that also use the RSML abbreviation.</p> <p>The <code>.rsml</code> file extension is also fine, but <code>.rsea</code> is preferred.</p>"},{"location":"language/#evaluation","title":"Evaluation","text":"<p>The \"evaluation\" is the act of going through every logic path and special action and evaluate the first, while running the second.</p> <p>If an evaluation encounters a primary operator (see Operators) in a true logic path, its value is returned and evaluation ends there.</p>"},{"location":"language/#use-of-msbuild-rids","title":"Use of MSBuild RIDs","text":"<p>MSBuild Runtime Identifiers are used for identifying systems and CPU architectures in Red Sea.</p> <p>You'll need to know them in order to write RSML.</p> <p>Here's a short example with common RIDs.</p> RID Meaning Example Usage in RSML (<code>official-25</code>) win-x64  Windows, 64-bit (based on x86) <code>win-x64 -&gt; \"Windows on x86-64\"</code> linux-x64  Linux, 64-bit (based on x86) <code>linux-x64 || \"Glad to see Linux getting love\"</code> linux-x86  Linux, 32-bit (based on x86) <code>linux-x86 ^! \"32-bit Linux not supported\"</code> osx-arm64  macOS, ARM 64-bit (based on Apple Silicon) <code>osx-arm64 -&gt; \"An apple a day...\"</code> win-arm64  Windows, ARM 64-bit <code>win-arm64 || \"Windows on ARM... Interesting.\"</code> linux-arm64  Linux, ARM 64-bit <code>linux-arm64 -&gt; \"Tux is happy\"</code> linux-arm  Linux, ARM 32-bit <code>linux-arm || \"Detected Linux on ARM32\"</code>"},{"location":"language/#use-of-regex-in-rsml","title":"Use of Regex in RSML","text":"<p>Tip</p> <p>RSML uses Regex at its core, so it might be worth learning Regex first, even if only the basics.</p> <p>RSML makes use of regular expressions to match MSBuild RIDs for different operating systems and CPU architectures.</p> <p>This means you can write flexible patterns to match a wide range of platforms with few characters.</p> Usage of Regex in RSML<pre><code>win.+ -&gt; \"This logic path matches any Windows system\" # (1)!\n</code></pre> <ol> <li>Or, to be precise, this logic path matches <code>win-x86</code>, <code>win-x64</code>, <code>win-arm64</code>, <code>win-arm</code>, etc.</li> </ol>"},{"location":"language/#language-specification","title":"Language Specification","text":"<p>Non-standardized</p> <p>Red Sea is not a standardized language. For the sake of examplifying without getting too technical, we'll be using the official-25 standard in most of the documentation, as it's the closest to an official specification.</p> <p>Red Sea is quite a simple language, but the lack of an official specification means behavior may vary across developer's implementations.</p>"},{"location":"language/#static-functionality-standardized","title":"Static Functionality (Standardized )","text":"<p>The following features are fully standardized and cannot be altered in any way by any language standards.</p> <ul> <li>The use of double quotes for enclosing values in logic path lines being mandatory and no standard being able to modify that.</li> <li>The use of MSBuild Runtime Identifiers.</li> <li>The use of standard Regex.</li> <li>Comment symbol (<code>#</code>).</li> <li>Invalid lines being comments.</li> </ul>"},{"location":"language/#extensible-functionality-partially-standardized","title":"Extensible Functionality (Partially Standardized )","text":"<p>The following features are partially standardized. For each feature, it's explained which part is standardized and which one isn't.</p> <ul> <li>Special Actions. Special actions can be added and customized by language standards, but the built-in one (<code>@EndAll</code>) cannot be removed or changed in any way.</li> <li>Operators. Language standards can pick which tokens (including common words) they wish to use as operators, but operators are still partially standardized as there must always be three operators and only the behaviors for the secondary and tertiary can be altered - the primary operator will always be the return operator.</li> </ul>"},{"location":"language/#implementation-specific-functionality-non-standardized","title":"Implementation-specific Functionality (Non-Standardized )","text":"<p>The following features are not standardized at all and can be customized at free will.</p> <ul> <li>Tokens used by operators. Each language standard can customize which tokens represent operators. Example: <code>official-25</code> uses operators <code>-&gt;</code>, <code>||</code>, <code>^!</code>.</li> </ul>"},{"location":"language/#operators","title":"Operators","text":"<p>In RSML, there are always three operators, named primary, secondary and tertiary.</p> <p>Below is a table with the operators, their tokens in <code>official-25</code> and what they actually do. For all of these, consider <code>val</code> as the argument they're passed.</p> Operator Name Operator Token (according to <code>official-25</code>) Functionality Functionality (according to <code>official-25</code>) Primary <code>-&gt;</code> Returns <code>val</code> (standards can't change this operator's functionality). Returns <code>val</code>. Secondary <code>||</code> Non-standardized. Outputs <code>val</code> to the <code>stdout</code>. Tertiary <code>^!</code> Non-standardized. Throws an error (error message set to <code>val</code>) and ends evaluation."},{"location":"language/#evaluation-process-flow","title":"Evaluation Process Flow","text":"<p>See also: Logic Path examples | Special Action handling</p> Strictly markup <p>Despite the usage of wording such as \"return\" and \"interpret\", RSML is purely declarative - it can not execute, compile or transpile code.</p> <p>RSML is evaluated from start to finish see Advanced Representation of the Process Flow, meaning that the very first logic path with a primary operator in it that matches will be used and the evaluation ends there. All the logic beyond that point is ignored completely.</p>"},{"location":"language/#simplified-representation","title":"Simplified Representation","text":"<pre><code>---\ntitle: Simplified Representation of the Evaluation Process Flow\n---\nflowchart LR\n  A[Start] --&gt; B[Next line];\n  B --&gt;F{Match?};\n  F --&gt;|No| B;\n  F --&gt;|Yes| C{Primary operator?};\n  C --&gt;|Yes| D[Return value + end];\n  C --&gt;|No| E[Execute operator];\n  E --&gt;B;</code></pre>"},{"location":"language/#advanced-representation","title":"Advanced Representation","text":"<pre><code>---\ntitle: Advanced Representation of the Evaluation Process Flow\n---\nflowchart LR\n  A[Start] --&gt; B[Next line];\n  B --&gt;C{Valid?};\n  C --&gt;|Yes| D{Type?};\n  C --&gt;|No| B;\n  D --&gt;|Logic| E{Match?};\n  D --&gt;|Action| F{Ends eval?};\n  D --&gt;|Comment| B;\n  E --&gt;|Yes| G{Primary op?};\n  E --&gt;|No| B;\n  F --&gt;|Yes| H[Finish];\n  F --&gt;|No| I[Run action];\n  I --&gt;B;\n  G --&gt;|Yes| J[Return + end];\n  G --&gt;|No| K[Execute operator];\n  K --&gt;B;</code></pre> Return operator <p>Only the primary operator triggers the return of a logic path's value. The other operators, unless explicitly defined to do such, will never stop the evaluation.</p>"},{"location":"language/#logic-paths","title":"Logic Paths","text":"<p>A logic path is the \"interactive\" part of RSML - the logic paths are what's evaluated.</p> <p>The syntax for this is quite simple.</p> <p>Things worth mentioning:</p> <ul> <li>The operator must be one of the 3 defined in the standard you're using (see Operators).</li> <li>The value (argument) must be enclosed in double quotes (<code>\"</code>).</li> <li>Spacing does not affect logic paths (<code>win.+ -&gt; \"hey\"</code> is the same as <code>win.+       -&gt;\"hey\"</code>).</li> </ul> Actual SyntaxExample 1Example 2Example 3Example 4 <pre><code>&lt;regex-expression&gt; &lt;operator&gt; &lt;value&gt;\n</code></pre> <pre><code>win.+ -&gt; \"This is a valid logic path syntax\" # (1)!\n</code></pre> <ol> <li>The line is valid, as long as the <code>-&gt;</code> operator is defined in the standard you're using. This will match all hosts with the Windows operating system.</li> </ol> <pre><code>(arch|ubuntu|debian)-x\\d\\d || \"Linux is nice\" # (1)!\n</code></pre> <ol> <li>This will match Debian, Ubuntu and Arch Linux distributions, as long as the CPU architecture is <code>x86</code> based (<code>x86</code> or <code>x64</code>).</li> </ol> <pre><code>osx.* || \"An apple a day keeps the doctor away, I guess...\" # (1)!\n</code></pre> <ol> <li>Keep in mind return values must be enclosed in double quotes.</li> </ol> <pre><code>win.* -&gt; \"I can smell windows.h\" # (1)!\nosx.* || \"An apple a day keeps the doctor away, I guess...\" # (2)!\n.+-x64 -&gt; \"64-bits is standard nowadays\" # (3)!\n</code></pre> <ol> <li>In <code>official-25</code>, this operator returns the logic path's value and ends evaluation (only if there's a match of course).</li> <li>In <code>official-25</code>, this operator outputs the logic path's value and does NOT end evaluation (only if there's a match of course).</li> <li>If one is on 64-bit Windows, this line wouldn't have been reached since the first line would have been a match and would've returned a value.</li> </ol>"},{"location":"language/#special-actions","title":"Special Actions","text":"<p>Special Actions (see Language Specification) are a partially-standardized feature of RSML, being responsible for evaluation-time modification to RSML aspects.</p> <p>Built-in Special Action</p> <p>As noted in the language specification section, <code>@EndAll</code> is the only immutable, built-in special action in RSML:</p> <ul> <li>Name cannot be changed: Must always be <code>@EndAll</code> (case-sensitive)</li> <li>Accepts no arguments: <code>@EndAll</code> is always argument-less, so any arguments given will be ignored.</li> <li>Functionality: Terminates evaluation immediately.</li> <li>Standards compliance: All implementations support this, as it's built-in.</li> </ul> <p>Special actions can change how the RSML parser behaves. Their usage varies with the programming language you're using for the RSML API. For that reason, in this page, we'll only talk about the syntax for these actions.</p> Actual SyntaxExample 1Example 2Example 3 <pre><code>@&lt;special-action&gt; [&lt;argument&gt;] # (1)!\n</code></pre> <ol> <li>The argument is optional, being an empty string if not specified. The argument must not contain any spaces and does not require enclosure.</li> </ol> <pre><code>@EndAll # (1)!\n</code></pre> <ol> <li>This is the only built-in standardized special action available. It'll be discussed later.</li> </ol> <pre><code>@MyAwesomeAction SomeValue # (1)!\n</code></pre> <ol> <li><code>SomeValue</code> does not need to be enclosed in double quotes.</li> </ol> <pre><code>@@ technically valid # (1)!\n</code></pre> <ol> <li>This line is valid, as there's no limitation to action names. Since the argument contains spaces, RSML will only use the first part of the argument (<code>technically</code>) as the whole argument.</li> </ol>"},{"location":"language/#comments","title":"Comments","text":"<p>Comments are quite simple in RSML. If a <code>#</code> character is at the start of a line, that line is considered a comment and will be fully ignored by the parser.</p> <p>However, every single line that's considered invalid is also a comment. Here are some examples with reasons as of why the lines are invalid.</p> Actual SyntaxExample 1Example 2Example 3Example 4 <pre><code># ... // (1)!\n</code></pre> <ol> <li>Worth mentioning that a <code>#</code> in any other location other than the start of a line is not a comment, unless the line is invalid.</li> </ol> <pre><code>some random text # (1)!\n</code></pre> <ol> <li>According to <code>official-25</code>, this line does not contain any operators or special actions, so it is invalid; therefore, a comment.</li> </ol> <pre><code>// wrong type of comment # (1)!\n</code></pre> <ol> <li>According to <code>official-25</code>, this line does not contain any operators or special actions, so it is invalid; therefore, a comment.</li> </ol> <pre><code># a comment // (1)!\n</code></pre> <ol> <li>This line is a comment.</li> </ol> <pre><code>win.+ || \"Valid line\" # (1)!\n</code></pre> <ol> <li>This line is valid, as it contains a logic path with an operator; therefore, not a comment.</li> </ol>"},{"location":"language/#syntax-reference","title":"Syntax Reference","text":"<p>This is a quick reference sheet on RSML's syntax.</p> Quick syntax reference <pre><code># Logic Paths\n&lt;regex-expression&gt; &lt;operator&gt; &lt;value&gt;\nwin.+ -&gt; \"My value\"\n\n# Special Actions\n@&lt;action-name&gt; [&lt;argument&gt;]\n@MyAction MyValue\n@EndAll\n\n# Comments\n# at the start of a sentence\n# this is a comment\n\n# Spacing is flexible\nwin.+ -&gt; \"valid\"\n.+-x64          -&gt;\"valid\"\nlinux.*-&gt;     \"valid\"\nosx-arm64-&gt;\"valid\"\n</code></pre>"},{"location":"language/standards/","title":"RSML Language Standards","text":"<p>Tip</p> <p>Before proceeding, ensure you understand:</p> <ul> <li>Evaluation Process</li> <li>Language Specification</li> <li>Basic Syntax</li> </ul> <p>Since anyone can create their own RSML language standard, documenting standards is crucial for interoperability and maintenance.</p>"},{"location":"language/standards/#specifying-which-standard-is-in-use","title":"Specifying which standard is in use","text":"<p>While optional, declaring your standard helps ensure consistent interpretation. That can be done by adding a comment to your RSML file, as shown below.</p> Note <ul> <li>The declaration is purely informational - it doesn't affect parsing.</li> <li>Custom parsers may use this hint to apply correct interpretation rules.</li> <li>Case-sensitive (<code>official-25</code> \u2260 <code>Official-25</code>).</li> </ul> Specifying the standardExample 1Example 2 <pre><code># !standard: &lt;standard-name&gt; (1)\n</code></pre> <ol> <li>Must be the first line of the file.</li> </ol> <pre><code># !standard: official-25\nwin.+ -&gt; \"Primary operator\"\nlinux.+ || \"Secondary operator\"\nosx.+ ^! \"Tertiary operator\"\n</code></pre> <pre><code># !standard: roadlike\nwin.+ ??? \"Primary operator\"\nlinux.+ &lt;&lt; \"Secondary operator\"\nosx.+ !!! \"Tertiary operator\"\n</code></pre>"},{"location":"language/standards/#documenting-your-standards","title":"Documenting your standards","text":"<p>It's impossible for us to document every single standard, but we try to keep the most important ones here.</p> <p>If you'd like to document your standard, you can follow this simple guide:</p> <ol> <li>Fork the rsml-docs repository.</li> <li>Copy this file into <code>/docs/language/standards/</code>.</li> <li>Give it the name of your standard (if your standard is <code>mystand</code>, you'd name it <code>mystand.md</code>).</li> <li>Edit the file with the details of your standard.</li> <li>Make a pull request.</li> <li>After reviewing, it'll either be accepted (you can then delete your fork) or rejected, in which case you can either make changes to it and try again or... not.</li> </ol> Tip <p>As long as you just follow the template and only edit what's relevant, your PR should be accepted.</p> <p>If your standard is relevant enough, we'll do our best to add it here. However, we'd still appreciate the Pull Request.</p>"},{"location":"language/standards/official-25/","title":"Official 25","text":"<p>Name: Official 25</p> <p>ID: <code>official-25</code></p> <p>Author: OceanApocalypseStudios</p> <p>Year: 2025</p> <p>License: Unlicense</p> <p>The language standard that's closest to an official language specification. Designed in 2025 by OceanApocalypseStudios to be universal and, for the lack of a better word, standard. It's used as the main language standard in the CLI as of v1.0.1 of RSML.</p>"},{"location":"language/standards/official-25/#operators","title":"Operators","text":"<p>Official 25 defines the following tokens as operators.</p> Operator Name Operator Token Functionality Primary <code>-&gt;</code> Returns <code>val</code>. Secondary <code>||</code> Outputs <code>val</code> to the standard output (<code>stdout</code>). Tertiary <code>^!</code> Throws an error (and ends evaluation) with error message <code>val</code>."},{"location":"language/standards/official-25/#special-actions","title":"Special Actions","text":"<p>Note</p> <p><code>@EndAll</code> is built into RSML (see Special Actions).</p> <p>Official 25 does not define any special actions.</p>"},{"location":"language/standards/roadlike/","title":"Road-Like","text":"<p>Name: Road-Like</p> <p>ID: <code>roadlike</code></p> <p>Author: OceanApocalypseStudios</p> <p>Year: 2025</p> <p>License: Unlicense</p> <p>A standard made for those who wish to migrate from MFRoad to RSML. It uses MFRoad's operators, so users only need to focus on re-learning the base syntax, not the operators too.</p>"},{"location":"language/standards/roadlike/#operators","title":"Operators","text":"<p>Road-Like defines the following tokens as operators.</p> Operator Name Operator Token Functionality Primary <code>???</code> Returns <code>val</code>. Secondary <code>&lt;&lt;</code> Outputs <code>val</code> to the standard output (<code>stdout</code>). Tertiary <code>!!!</code> Throws an error (and ends evaluation) with error message <code>val</code>."},{"location":"language/standards/roadlike/#special-actions","title":"Special Actions","text":"<p>Note</p> <p><code>@EndAll</code> is built into RSML (see Special Actions).</p> <p>Road-Like does not define any special actions.</p>"}]}