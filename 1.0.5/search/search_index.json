{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#welcome-to-red-sea-markup-language-docs","title":"Welcome to Red Sea Markup Language Docs","text":"<p>Warning</p> <p>The documentation for RSML is a work in progress.</p> <p>Red Sea Markup Language is the powerful and robust fork of MF's CrossRoad Solution, a language designed to dynamically interpret different logic paths based on the local host OS and CPU architecture.</p> <p>RSML (short for Red Sea Markup Language) can currently be used in C# and Python, as well as in its own CLI.</p> <p>This documentation is licensed under the GFDL.</p> <p>Copyright \u00a9 2025  OceanApocalypseStudios</p> <p>Permission is granted to copy, distribute and/or modify this document under the terms of the GNU Free Documentation License, Version 1.3 or any later version published by the Free Software Foundation; with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.</p>"},{"location":"#why-use-red-sea-markup-language","title":"Why use Red Sea Markup Language?","text":"<ul> <li> <p> Made for logic, logically.</p> <p>RSML is logic-heavy and therefore, everything about it is logical and easy to understand and use. One could say everything about it makes sense.</p> <p> The Language</p> </li> <li> <p> Easily embeddable.</p> <p>RSML is, obviously, intended to be used programmatically. RSML's fresh and easy API allow for an excellent experience embedding RSML into your program.</p> <p> The API</p> </li> <li> <p> Directly in your Terminal.</p> <p>Heavy-logic shouldn't mean \"open your editor and start writing <code>if</code> clauses\". That's where RSML's handy CLI comes in. It's a great way to quickly evaluate RSML files, at a relatively less complex level, without having to jump into your editor and write code.</p> <p> The CLI</p> </li> <li> <p> Our love for Open Source.</p> <p>RSML is the creation of a software and indie-game studios (OceanApocalypseStudios) that loves open-source. We can assure it will be free and open-source forever. It's also licensed under the very permissive MIT License, which is more than great!</p> <p> The GitHub Repository</p> </li> </ul>"},{"location":"#useful-links","title":"Useful Links","text":"<p>To further enhance your experience with RSML, we offer a list of useful links in this journey through our logic-heavy markup language.</p> <ul> <li> <p> GitHub Repository</p> <p>The official repository for Red Sea Markup Language.</p> <p> Visit</p> </li> <li> <p> NuGet Package</p> <p>RSML for C# is the main way to use RSML, so the NuGet link is going to be one of your best bets for getting help, among other things, even if you're using RSML with a language other than C#.</p> <p> Visit</p> </li> <li> <p> RSML for Python</p> <p>RSML for Python was the first port of RSML to another programming language to exist.</p> <p> Visit the repository</p> </li> <li> <p> RSML's Documentation Repository.</p> <p>While it might seem a bit redundant (after all, you're already here), it's useful if you wish to build the documentation locally, that is, if you want a offline copy of it.</p> <p> Visit the repository</p> </li> </ul>"},{"location":"changelog/","title":"RSML Changelog","text":"<p>The changelog for Red Sea Markup Language.</p>"},{"location":"changelog/#v105","title":"v1.0.5","text":"<p>Released on 21/06/2025.</p> <p>CLI</p> <ul> <li>The CLI now builds using the Ahead-of-Time compiler (AOT) for native DLLs.</li> </ul>"},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#contributing","title":"Contributing","text":"<p>We really appreciate contributions - they help us focus on releasing faster and better.</p> <p>That being said, there are some rules and guidelines you must follow.</p> <ul> <li> <p> KISS: Keep it simple, stupid.</p> <p>Make sure your changes are understandable and do not affect the simplicity of the documentation negatively.</p> </li> <li> <p> Know your branches.</p> <p>Make changes to <code>main</code>, NEVER to <code>gh-pages</code>.</p> </li> <li> <p> If it ain't broken, don't redesign it.</p> <p>Unless the current theme/CSS feels wrong or is broken, don't change it. Seriously. Don't.</p> </li> <li> <p> Fixing typos is noble; flooding PRs with them is chaos.</p> <p>Typo squatting is perfectly fine and helpful, but don't make too many Pull Requests to fix typos in a row, as it causes unnecessary spam. The best alternative is to \"bundle\" several typo fixes in one PR.</p> </li> </ul>"},{"location":"contributing/#questions","title":"Questions","text":"<p>Sadly, OceanApocalypseStudios does not have a formal way of contact (yet). Therefore, I'll allow users with questions to use my public e-mail instead, but please only make use of it if the questions are really, really important. Thank you.</p> <p>E-mail: <code>real_mf366@yahoo.com</code></p>"},{"location":"api/","title":"RSML as an API","text":""},{"location":"api/#rsml-as-an-api","title":"RSML as an API","text":"<p>Tip</p> <p>It's recommended to know the actual language itself before learning how to use RSML programmatically.</p> <p>RSML truly becomes powerful when used programmatically. As of right now, RSML can officially be used in two programming languages: C# and Python.</p> <p>RSML is written in C#, so if you want maximum support, it's recommended you go with the same language.</p>"},{"location":"api/#getting-started","title":"Getting Started","text":"<p>To get started using RSML programmatically, first pick one of those languages. Then, follow their own guides, as setup is different for both.</p> <p>After following the installation and setup guide, you can view our usage examples or actual how-to guides.</p>"},{"location":"api/#why-use-rsmls-api","title":"Why use RSML's API?","text":"<p>If used simply as a language, RSML does not do much. It's the evaluation process that gives it power, and it can only be evaluated via an interface. That's where programming languages come into play.</p>"},{"location":"api/demos/","title":"Usage Demos","text":""},{"location":"api/demos/#api-usage-examples","title":"API Usage Examples","text":"<p>These are usage examples of the RSML API.</p>"},{"location":"api/demos/#package-manager","title":"Package Manager","text":"<p>In the example below, RSML is used in the context of a package manager. The user packaging their app adds a <code>.rsea</code> file that the package manager evaluates. Each logic path of the file takes the package manager to a different script, given how different build/installation setup might be given the OS and CPU architecture. This example only exemplifies how RSMl comes into play, it is not a guide on how to create package managers.</p> C#Python <pre><code>using System.IO;\nusing RSML.Parser;\n\n/*\n    * Adapted from rsml-demos\n    * For the full code, see https://github.com/OceanApocalypseStudios/rsml-demos/\n*/\n\nstring PACKAGE_NAME = \"Example Package\";\n\n// Reading from the file\n// (Assume we're passed a FileInfo named rsmlFile)\nstring data = File.ReadAllText(rsmlFile.FullName);\n\n// Creating the parser\nRSParser parser = new(data);\n\n// Setting up the parser to match official-25\nparser.DefineOperator(OperatorType.Primary, \"-&gt;\");\nparser.DefineOperator(OperatorType.Secondary, \"||\");\nparser.DefineOperator(OperatorType.Tertiary, \"^!\");\n\nparser.RegisterAction(OperatorType.Secondary, (_, value) =&gt; Console.WriteLine(value));\nparser.RegisterAction(OperatorType.Tertiary, (_, value) =&gt; throw new RSMLRuntimeException(value));\n\n// Parsing\nstring? result = parser.EvaluateRSML(true) ??\n    throw new EvaluateException($\"No setup scripts found for this machine in {PACKAGE_NAME}.\");\n\nFileInfo file = new(result);\n\nreturn !file.Exists ?\n    throw new FileNotFoundException(\"Such script does not exist.\")\n    : file;\n</code></pre> <pre><code>import rsml_python\n\n# Creating the executable\nPATH_TO_EXE: str = ... # insert path here\nRS_EXE: RedSeaCLIExecutable = RedSeaCLIExecutable(PATH_TO_EXE)\n\n# Creating the document\ndoc: RedSeaDocument = RedSeaDocument()\ndoc.load_from_string(data)\n\n# Loading the document into the executable\nRS_EXE.load_document(doc)\n\n# Parsing\nresult: str = RS_EXE.evaluate_document(expands_any=True)\n\n# Checking the result\nif result.startswith((\"[WARNING]\", \"[ERROR]\")):\n    raise ValueError(f\"No setup scripts found for this machine in {PACKAGE_NAME}.\")\n</code></pre>"},{"location":"api/csharp/","title":"RSML in C#","text":"<p>RSML for C# is a great and solid choice for learning to use RSML programmatically, as it has the best support.</p>"},{"location":"api/csharp/#installation","title":"Installation","text":"<p>RSML can be installed in 2 ways: package reference (via NuGet) or project reference (building RSML inside your solution).</p>"},{"location":"api/csharp/#package-reference","title":"Package Reference","text":"<p>Installing RSML via its NuGet package is the recommended way to install RSML, as it guarantees stability.</p> .NET CLIProject FileVisual Studio (PMC)Visual Studio (GUI) <p>Simply run the following line in the terminal.</p> <pre><code>dotnet add package RSML --version 1.0.5\n</code></pre> <p>To install RSML via your project file, simply ass the following line to an <code>&lt;ItemGroup&gt;</code>.</p> <pre><code>&lt;PackageReference Include=\"RSML\" Version=\"1.0.5\" /&gt;\n</code></pre> <p>If you use Visual Studio, you can instead run the following line in the builtin Package Manager Console.</p> <pre><code>NuGet\\Install-Package RSML -Version 1.0.5\n</code></pre> <p>Visual Studio comes with a NuGet Package Installation GUI.</p> <ol> <li>Select Browse and search RSML.</li> </ol> <p></p> <p>Search RSML on NuGet.</p> <ol> <li>Choose the correct version and click Install.</li> </ol> <p></p> <p>Install RSML.</p> <ol> <li>If prompted to accept a license, do so.</li> </ol>"},{"location":"api/csharp/#project-reference-not-recommended","title":"Project Reference (Not recommended)","text":"<p>If, for whatever reason, you need the latest nightly updates, you may also add the RSML project to your solution.</p> <p>Please keep in mind that not all nightly updates are guaranteed to be bug-free or stable. Nightly updates are also not documented, only stable versions are.</p> <pre><code>cd YourSolution/YourProject/\n# Assuming you've got the RSML project at YourSolution/RSML/\ndotnet add reference ../RSML/RSML.csproj\n</code></pre> <ol> <li>If your solution is included in a <code>git</code> repository already, consider using Git Submodules instead.</li> </ol>"},{"location":"api/csharp/reference/","title":"API Reference (C#)","text":"<p>The API reference for RSML in C# is organized by namespace and then class.</p>"},{"location":"api/csharp/reference/#overview","title":"Overview","text":"<ul> <li> <p><code>RSML</code></p> <ul> <li><code>RSDocument</code><ul> <li><code>EvaluateDocument()</code></li> <li><code>EvaluateDocument(string lineSeparation)</code></li> <li><code>EvaluateDocument(bool expandAny, string? lineSeparation = null)</code></li> <li><code>EvaluateDocument(string customRid, string? lineSeparation = null)</code></li> <li><code>EvaluateDocument(string customRid, bool expandAny, string? lineSeparation = null)</code></li> <li><code>LoadRSMLFromFile(string filepath)</code></li> <li><code>LoadRSMLFromFileAsync(string filepath)</code></li> <li><code>LoadRSMLFromFileIntoDocument(string filepath)</code></li> <li><code>NewFromFile(string filepath)</code></li> <li><code>RSDocument(string rsml)</code></li> <li><code>RSDocument(StringReader reader)</code></li> <li><code>RSDocument(RSParser parser)</code></li> <li><code>SaveRSMLToFile(string filepath)</code></li> <li><code>ToString()</code></li> </ul> </li> </ul> </li> <li> <p><code>RSML.Exceptions</code></p> <ul> <li><code>ImmutableActionException</code><ul> <li><code>ImmutableActionException()</code></li> <li><code>ImmutableActionException(string message)</code></li> <li><code>ImmutableActionException(string? message, Exception? innerException)</code></li> </ul> </li> <li><code>RSMLRuntimeException</code><ul> <li><code>RSMLRuntimeException()</code></li> <li><code>RSMLRuntimeException(string message)</code></li> <li><code>RSMLRuntimeException(string? message, Exception? innerException)</code></li> </ul> </li> <li><code>UndefinedActionException</code><ul> <li><code>UndefinedActionException()</code></li> <li><code>UndefinedActionException(string message)</code></li> <li><code>UndefinedActionException(string? message, Exception? innerException)</code></li> </ul> </li> <li><code>UndefinedSpecialException</code><ul> <li><code>UndefinedSpecialException()</code></li> <li><code>UndefinedSpecialException(string message)</code></li> <li><code>UndefinedSpecialException(string? message, Exception? innerException)</code></li> </ul> </li> </ul> </li> <li> <p><code>RSML.Parser</code></p> </li> </ul>"},{"location":"api/csharp/reference/RSML/","title":"Namespace Overview","text":"<ul> <li><code>RSDocument</code><ul> <li><code>EvaluateDocument()</code></li> <li><code>EvaluateDocument(string lineSeparation)</code></li> <li><code>EvaluateDocument(bool expandAny, string? lineSeparation = null)</code></li> <li><code>EvaluateDocument(string customRid, string? lineSeparation = null)</code></li> <li><code>EvaluateDocument(string customRid, bool expandAny, string? lineSeparation = null)</code></li> <li><code>LoadRSMLFromFile(string filepath)</code></li> <li><code>LoadRSMLFromFileAsync(string filepath)</code></li> <li><code>LoadRSMLFromFileIntoDocument(string filepath)</code></li> <li><code>NewFromFile(string filepath)</code></li> <li><code>RSDocument(string rsml)</code></li> <li><code>RSDocument(StringReader reader)</code></li> <li><code>RSDocument(RSParser parser)</code></li> <li><code>SaveRSMLToFile(string filepath)</code></li> <li><code>ToString()</code></li> </ul> </li> </ul>"},{"location":"api/csharp/reference/RSML/RSDocument/","title":"<code>RSML.RSDocument</code> Class","text":"<p>Represents a Red Sea Markup Language document.</p>"},{"location":"api/csharp/reference/RSML/RSDocument/#hierarchy","title":"Hierarchy","text":"<pre><code>flowchart BT\n    RSDocument --&gt; System.Object</code></pre>"},{"location":"api/csharp/reference/RSML/RSDocument/#constructors","title":"Constructors","text":"<p><code>RSDocument</code> contains 3 constructor methods.</p>"},{"location":"api/csharp/reference/RSML/RSDocument/#rsdocumentstring-rsml","title":"<code>RSDocument(string rsml)</code>","text":"<p>Creates a new document from a string containing RSML.</p>"},{"location":"api/csharp/reference/RSML/RSDocument/#parameters","title":"Parameters","text":"<code>string rsml</code> <p>The RSML data to load, in the form of a <code>System.String</code>.</p>"},{"location":"api/csharp/reference/RSML/RSDocument/#rsdocumentstringreader-reader","title":"<code>RSDocument(StringReader reader)</code>","text":"<p>Creates a new document from a <code>StringReader</code> containing RSML.</p>"},{"location":"api/csharp/reference/RSML/RSDocument/#parameters_1","title":"Parameters","text":"<code>StringReader reader</code> <p>The reader containing RSML.</p>"},{"location":"api/csharp/reference/RSML/RSDocument/#rsdocumentrsparser-parser","title":"<code>RSDocument(RSParser parser)</code>","text":"<p>Creates a new document from a already initialized parser.</p>"},{"location":"api/csharp/reference/RSML/RSDocument/#parameters_2","title":"Parameters","text":"<code>RSParser parser</code> <p>An instance of a Red Sea Markup Language parser.</p>"},{"location":"api/csharp/reference/RSML/RSDocument/#static-factories","title":"Static Factories","text":"<p><code>RSDocument</code> contains 2 static factory methods.</p>"},{"location":"api/csharp/reference/RSML/RSDocument/#loadrsmlfromfileintodocumentstring-filepath","title":"<code>LoadRSMLFromFileIntoDocument(string filepath)</code>","text":"<p>Loads a RSML file into a <code>RSDocument</code>.</p>"},{"location":"api/csharp/reference/RSML/RSDocument/#parameters_3","title":"Parameters","text":"<code>string filepath</code> <p>The path to the file to load.</p>"},{"location":"api/csharp/reference/RSML/RSDocument/#returns","title":"Returns","text":"<p><code>RSDocument</code> : The document containing ready-to-parse RSML.</p>"},{"location":"api/csharp/reference/RSML/RSDocument/#newfromfilestring-filepath","title":"<code>NewFromFile(string filepath)</code>","text":"<p>Creates a new document from a filepath.</p>"},{"location":"api/csharp/reference/RSML/RSDocument/#parameters_4","title":"Parameters","text":"<code>string filepath</code> <p>The path to the file to load.</p>"},{"location":"api/csharp/reference/RSML/RSDocument/#exceptions","title":"Exceptions","text":"<code>FileNotFoundException</code> The file could not be located."},{"location":"api/csharp/reference/RSML/RSDocument/#returns_1","title":"Returns","text":"<p><code>RSDocument</code> : The document containing ready-to-parse RSML.</p>"},{"location":"api/csharp/reference/RSML/RSDocument/#static-methods","title":"Static Methods","text":"<p><code>RSDocument</code> contains 2 static (non-factory) methods.</p>"},{"location":"api/csharp/reference/RSML/RSDocument/#loadrsmlfromfilestring-filepath","title":"<code>LoadRSMLFromFile(string filepath)</code>","text":"<p>Loads a RSML file into a string.</p>"},{"location":"api/csharp/reference/RSML/RSDocument/#parameters_5","title":"Parameters","text":"<code>string filepath</code> <p>The path to the file to load.</p>"},{"location":"api/csharp/reference/RSML/RSDocument/#returns_2","title":"Returns","text":"<p><code>System.String</code> : The text contained in the file.</p>"},{"location":"api/csharp/reference/RSML/RSDocument/#loadrsmlfromfileasyncstring-filepath","title":"<code>LoadRSMLFromFileAsync(string filepath)</code>","text":"<p>Loads a RSML file into a string, asynchronously.</p>"},{"location":"api/csharp/reference/RSML/RSDocument/#parameters_6","title":"Parameters","text":"<code>string filepath</code> <p>The path to the file to load.</p>"},{"location":"api/csharp/reference/RSML/RSDocument/#returns_3","title":"Returns","text":"<p><code>System.Threading.Tasks.Task&lt;System.String&gt;</code> : The text contained in the file.</p>"},{"location":"api/csharp/reference/RSML/RSDocument/#saversmltofilestring-filepath","title":"<code>SaveRSMLToFile(string filepath)</code>","text":"<p>Saves RSML into a file.</p>"},{"location":"api/csharp/reference/RSML/RSDocument/#parameters_7","title":"Parameters","text":"<code>string filepath</code> <p>The path to the file to write the RSML data to.</p>"},{"location":"api/csharp/reference/RSML/RSDocument/#instance-methods","title":"Instance Methods","text":"<p><code>RSDocument</code> contains 6 instance methods.</p>"},{"location":"api/csharp/reference/RSML/RSDocument/#evaluatedocument","title":"<code>EvaluateDocument()</code>","text":"<p>Parses and evaluates the document.</p>"},{"location":"api/csharp/reference/RSML/RSDocument/#returns_4","title":"Returns","text":"<code>System.String</code> <p>The string matching the return value of the only match that had a primary operator.</p> <code>null</code> <p>There were no primary matches.</p>"},{"location":"api/csharp/reference/RSML/RSDocument/#evaluatedocumentstring-lineseparation","title":"<code>EvaluateDocument(string lineSeparation)</code>","text":"<p>Parses and evaluates the document.</p>"},{"location":"api/csharp/reference/RSML/RSDocument/#parameters_8","title":"Parameters","text":"<code>string lineSeparation</code> <p>The custom line separation character to use, instead of <code>System.Environment.NewLine</code>.</p>"},{"location":"api/csharp/reference/RSML/RSDocument/#returns_5","title":"Returns","text":"<code>System.String</code> <p>The string matching the return value of the only match that had a primary operator.</p> <code>null</code> <p>There were no primary matches.</p>"},{"location":"api/csharp/reference/RSML/RSDocument/#evaluatedocumentbool-expandany-string-lineseparation-null","title":"<code>EvaluateDocument(bool expandAny, string? lineSeparation = null)</code>","text":"<p>Parses and evaluates the document.</p>"},{"location":"api/csharp/reference/RSML/RSDocument/#parameters_9","title":"Parameters","text":"<code>bool expandAny</code> <p>If set to <code>true</code>, expands <code>any</code> into Regex expression <code>.+</code>, indicating that any RID will be a match.</p> <code>string? lineSeparation = null</code> <p>The custom line separation character to use, instead of <code>System.Environment.NewLine</code>. Defaults to <code>null</code>. If <code>null</code>, falls back to <code>System.Environment.NewLine</code>.</p>"},{"location":"api/csharp/reference/RSML/RSDocument/#returns_6","title":"Returns","text":"<code>System.String</code> <p>The string matching the return value of the only match that had a primary operator.</p> <code>null</code> <p>There were no primary matches.</p>"},{"location":"api/csharp/reference/RSML/RSDocument/#evaluatedocumentstring-customrid-string-lineseparation-null","title":"<code>EvaluateDocument(string customRid, string? lineSeparation = null)</code>","text":"<p>Parses and evaluates the document.</p>"},{"location":"api/csharp/reference/RSML/RSDocument/#parameters_10","title":"Parameters","text":"<code>string customRid</code> <p>A custom RID to pass to the parser, instead of the host's RID.</p> <code>string? lineSeparation = null</code> <p>The custom line separation character to use, instead of <code>System.Environment.NewLine</code>. Defaults to <code>null</code>. If <code>null</code>, falls back to <code>System.Environment.NewLine</code>.</p>"},{"location":"api/csharp/reference/RSML/RSDocument/#returns_7","title":"Returns","text":"<code>System.String</code> <p>The string matching the return value of the only match that had a primary operator.</p> <code>null</code> <p>There were no primary matches.</p>"},{"location":"api/csharp/reference/RSML/RSDocument/#evaluatedocumentstring-customrid-bool-expandany-string-lineseparation-null","title":"<code>EvaluateDocument(string customRid, bool expandAny, string? lineSeparation = null)</code>","text":"<p>Parses and evaluates the document.</p>"},{"location":"api/csharp/reference/RSML/RSDocument/#parameters_11","title":"Parameters","text":"<code>string customRid</code> <p>A custom RID to pass to the parser, instead of the host's RID.</p> <code>bool expandAny</code> <p>If set to <code>true</code>, expands <code>any</code> into Regex expression <code>.+</code>, indicating that any RID will be a match.</p> <code>string? lineSeparation = null</code> <p>The custom line separation character to use, instead of <code>System.Environment.NewLine</code>. Defaults to <code>null</code>. If <code>null</code>, falls back to <code>System.Environment.NewLine</code>.</p>"},{"location":"api/csharp/reference/RSML/RSDocument/#returns_8","title":"Returns","text":"<code>System.String</code> <p>The string matching the return value of the only match that had a primary operator.</p> <code>null</code> <p>There were no primary matches.</p>"},{"location":"api/csharp/reference/RSML/RSDocument/#tostring","title":"<code>ToString()</code>","text":"<p>Note</p> <p><code>ToString()</code> overwrites parent class' <code>System.Object.ToString()</code>.</p> <p>Returns the document's contents.</p>"},{"location":"api/csharp/reference/RSML/RSDocument/#returns_9","title":"Returns","text":"<p><code>System.String</code> : The loaded RSML.</p>"},{"location":"api/guides/","title":"About our Guides","text":""},{"location":"api/guides/#how-to-guides","title":"How-to Guides","text":""},{"location":"language/","title":"RSML as a Language","text":""},{"location":"language/#rsml-as-a-language","title":"RSML as a Language","text":"Note <p>To make RSML easier to understand for beginners, this page starts with the \"easiest\" details of the language.</p>"},{"location":"language/#files","title":"Files","text":"<p>The official standard file extension for Red Sea Markup Language files is <code>.rsea</code>, to avoid it being confused with other languages that also use the RSML abbreviation.</p> <p>The <code>.rsml</code> file extension is also fine, but <code>.rsea</code> is preferred.</p>"},{"location":"language/#evaluation","title":"Evaluation","text":"<p>The \"evaluation\" is the act of going through every logic path and special action and evaluate the first, while running the second.</p> <p>If an evaluation encounters a primary operator (see Operators) in a true logic path, its value is returned and evaluation ends there.</p>"},{"location":"language/#use-of-msbuild-rids","title":"Use of MSBuild RIDs","text":"<p>MSBuild Runtime Identifiers are used for identifying systems and CPU architectures in Red Sea.</p> <p>You'll need to know them in order to write RSML.</p> <p>Here's a short example with common RIDs.</p> RID Meaning Example Usage in RSML (<code>official-25</code>) win-x64  Windows, 64-bit (based on x86) <code>win-x64 -&gt; \"Windows on x86-64\"</code> linux-x64  Linux, 64-bit (based on x86) <code>linux-x64 || \"Glad to see Linux getting love\"</code> linux-x86  Linux, 32-bit (based on x86) <code>linux-x86 ^! \"32-bit Linux not supported\"</code> osx-arm64  macOS, ARM 64-bit (based on Apple Silicon) <code>osx-arm64 -&gt; \"An apple a day...\"</code> win-arm64  Windows, ARM 64-bit <code>win-arm64 || \"Windows on ARM... Interesting.\"</code> linux-arm64  Linux, ARM 64-bit <code>linux-arm64 -&gt; \"Tux is happy\"</code> linux-arm  Linux, ARM 32-bit <code>linux-arm || \"Detected Linux on ARM32\"</code>"},{"location":"language/#use-of-regex-in-rsml","title":"Use of Regex in RSML","text":"<p>Tip</p> <p>RSML uses Regex at its core, so it might be worth learning Regex first, even if only the basics.</p> <p>RSML makes use of regular expressions to match MSBuild RIDs for different operating systems and CPU architectures.</p> <p>This means you can write flexible patterns to match a wide range of platforms with few characters.</p> Usage of Regex in RSML<pre><code>win.+ -&gt; \"This logic path matches any Windows system\" # (1)!\n</code></pre> <ol> <li>Or, to be precise, this logic path matches <code>win-x86</code>, <code>win-x64</code>, <code>win-arm64</code>, <code>win-arm</code>, etc.</li> </ol>"},{"location":"language/#language-specification","title":"Language Specification","text":"<p>Non-standardized</p> <p>Red Sea is not a standardized language. For the sake of examplifying without getting too technical, we'll be using the official-25 standard in most of the documentation, as it's the closest to an official specification.</p> <p>Red Sea is quite a simple language, but the lack of an official specification means behavior may vary across developer's implementations.</p>"},{"location":"language/#static-functionality-standardized","title":"Static Functionality (Standardized )","text":"<p>The following features are fully standardized and cannot be altered in any way by any language standards.</p> <ul> <li>The use of double quotes for enclosing values in logic path lines being mandatory and no standard being able to modify that.</li> <li>The use of MSBuild Runtime Identifiers.</li> <li>The use of standard Regex.</li> <li>Comment symbol (<code>#</code>).</li> <li>Invalid lines being comments.</li> </ul>"},{"location":"language/#extensible-functionality-partially-standardized","title":"Extensible Functionality (Partially Standardized )","text":"<p>The following features are partially standardized. For each feature, it's explained which part is standardized and which one isn't.</p> <ul> <li>Special Actions. Special actions can be added and customized by language standards, but the built-in one (<code>@EndAll</code>) cannot be removed or changed in any way.</li> <li>Operators. Language standards can pick which tokens (including common words) they wish to use as operators, but operators are still partially standardized as there must always be three operators and only the behaviors for the secondary and tertiary can be altered - the primary operator will always be the return operator.</li> </ul>"},{"location":"language/#implementation-specific-functionality-non-standardized","title":"Implementation-specific Functionality (Non-Standardized )","text":"<p>The following features are not standardized at all and can be customized at free will.</p> <ul> <li>Tokens used by operators. Each language standard can customize which tokens represent operators. Example: <code>official-25</code> uses operators <code>-&gt;</code>, <code>||</code>, <code>^!</code>.</li> </ul>"},{"location":"language/#operators","title":"Operators","text":"<p>In RSML, there are always three operators, named primary, secondary and tertiary.</p> <p>Below is a table with the operators, their tokens in <code>official-25</code> and what they actually do. For all of these, consider <code>val</code> as the argument they're passed.</p> Operator Name Operator Token (according to <code>official-25</code>) Functionality Functionality (according to <code>official-25</code>) Primary <code>-&gt;</code> Returns <code>val</code> (standards can't change this operator's functionality). Returns <code>val</code>. Secondary <code>||</code> Non-standardized. Outputs <code>val</code> to the <code>stdout</code>. Tertiary <code>^!</code> Non-standardized. Throws an error (error message set to <code>val</code>) and ends evaluation."},{"location":"language/#evaluation-process-flow","title":"Evaluation Process Flow","text":"<p>See also</p> <ul> <li>Logic Path examples</li> <li>Special Action handling</li> </ul> Strictly markup <p>Despite the usage of wording such as \"return\" and \"interpret\", RSML is purely declarative - it can not execute, compile or transpile code.</p> <p>RSML is evaluated from start to finish (see Advanced Representation of the Process Flow), meaning that the very first logic path with a primary operator in it that matches will be used and the evaluation ends there. All the logic beyond that point is ignored completely.</p>"},{"location":"language/#simplified-representation","title":"Simplified Representation","text":"<pre><code>---\ntitle: Simplified Representation of the Evaluation Process Flow\n---\nflowchart LR\n  A[Start] --&gt; B[Next line];\n  B --&gt;F{Match?};\n  F --&gt;|No| B;\n  F --&gt;|Yes| C{Primary operator?};\n  C --&gt;|Yes| D[Return value + end];\n  C --&gt;|No| E[Execute operator];\n  E --&gt;B;</code></pre>"},{"location":"language/#advanced-representation","title":"Advanced Representation","text":"<pre><code>---\ntitle: Advanced Representation of the Evaluation Process Flow\n---\nflowchart LR\n  A[Start] --&gt; B[Next line];\n  B --&gt;C{Valid?};\n  C --&gt;|Yes| D{Type?};\n  C --&gt;|No| B;\n  D --&gt;|Logic| E{Match?};\n  D --&gt;|Action| F{Ends eval?};\n  D --&gt;|Comment| B;\n  E --&gt;|Yes| G{Primary op?};\n  E --&gt;|No| B;\n  F --&gt;|Yes| H[Finish];\n  F --&gt;|No| I[Run action];\n  I --&gt;B;\n  G --&gt;|Yes| J[Return + end];\n  G --&gt;|No| K[Execute operator];\n  K --&gt;B;</code></pre> Return operator <p>Only the primary operator triggers the return of a logic path's value. The other operators, unless explicitly defined to do such, will never stop the evaluation.</p>"},{"location":"language/#logic-paths","title":"Logic Paths","text":"<p>A logic path is the \"interactive\" part of RSML - the logic paths are what's evaluated.</p> <p>The syntax for this is quite simple.</p> <p>Things worth mentioning:</p> <ul> <li>The operator must be one of the 3 defined in the standard you're using (see Operators).</li> <li>The value (argument) must be enclosed in double quotes (<code>\"</code>).</li> <li>Spacing does not affect logic paths (<code>win.+ -&gt; \"hey\"</code> is the same as <code>win.+       -&gt;\"hey\"</code>).</li> </ul> Actual SyntaxExample 1Example 2Example 3Example 4 <pre><code>&lt;regex-expression&gt; &lt;operator&gt; &lt;value&gt;\n</code></pre> <pre><code>win.+ -&gt; \"This is a valid logic path syntax\" # (1)!\n</code></pre> <ol> <li>The line is valid, as long as the <code>-&gt;</code> operator is defined in the standard you're using. This will match all hosts with the Windows operating system.</li> </ol> <pre><code>(arch|ubuntu|debian)-x\\d\\d || \"Linux is nice\" # (1)!\n</code></pre> <ol> <li>This will match Debian, Ubuntu and Arch Linux distributions, as long as the CPU architecture is <code>x86</code> based (<code>x86</code> or <code>x64</code>).</li> </ol> <pre><code>osx.* || \"An apple a day keeps the doctor away, I guess...\" # (1)!\n</code></pre> <ol> <li>Keep in mind return values must be enclosed in double quotes.</li> </ol> <pre><code>win.* -&gt; \"I can smell windows.h\" # (1)!\nosx.* || \"An apple a day keeps the doctor away, I guess...\" # (2)!\n.+-x64 -&gt; \"64-bits is standard nowadays\" # (3)!\n</code></pre> <ol> <li>In <code>official-25</code>, this operator returns the logic path's value and ends evaluation (only if there's a match of course).</li> <li>In <code>official-25</code>, this operator outputs the logic path's value and does NOT end evaluation (only if there's a match of course).</li> <li>If one is on 64-bit Windows, this line wouldn't have been reached since the first line would have been a match and would've returned a value.</li> </ol>"},{"location":"language/#special-actions","title":"Special Actions","text":"<p>Special Actions (see Language Specification) are a partially-standardized feature of RSML, being responsible for evaluation-time modification to RSML aspects.</p> <p>Built-in Special Action</p> <p>As noted in the language specification section, <code>@EndAll</code> is the only immutable, built-in special action in RSML:</p> <ul> <li>Name cannot be changed: Must always be <code>@EndAll</code> (case-sensitive)</li> <li>Accepts no arguments: <code>@EndAll</code> is always argument-less, so any arguments given will be ignored.</li> <li>Functionality: Terminates evaluation immediately.</li> <li>Standards compliance: All implementations support this, as it's built-in.</li> </ul> <p>Special actions can change how the RSML parser behaves. Their usage varies with the programming language you're using for the RSML API. For that reason, in this page, we'll only talk about the syntax for these actions.</p> Actual SyntaxExample 1Example 2Example 3 <pre><code>@&lt;special-action&gt; [&lt;argument&gt;] # (1)!\n</code></pre> <ol> <li>The argument is optional, being an empty string if not specified. The argument must not contain any spaces and does not require enclosure.</li> </ol> <pre><code>@EndAll # (1)!\n</code></pre> <ol> <li>This is the only built-in standardized special action available. It'll be discussed later.</li> </ol> <pre><code>@MyAwesomeAction SomeValue # (1)!\n</code></pre> <ol> <li><code>SomeValue</code> does not need to be enclosed in double quotes.</li> </ol> <pre><code>@@ technically valid # (1)!\n</code></pre> <ol> <li>This line is valid, as there's no limitation to action names. Since the argument contains spaces, RSML will only use the first part of the argument (<code>technically</code>) as the whole argument.</li> </ol>"},{"location":"language/#comments","title":"Comments","text":"<p>Comments are quite simple in RSML. If a <code>#</code> character is at the start of a line, that line is considered a comment and will be fully ignored by the parser.</p> <p>However, every single line that's considered invalid is also a comment. Here are some examples with reasons as of why the lines are invalid.</p> Actual SyntaxExample 1Example 2Example 3Example 4 <pre><code># ... // (1)!\n</code></pre> <ol> <li>Worth mentioning that a <code>#</code> in any other location other than the start of a line is not a comment, unless the line is invalid.</li> </ol> <pre><code>some random text # (1)!\n</code></pre> <ol> <li>According to <code>official-25</code>, this line does not contain any operators or special actions, so it is invalid; therefore, a comment.</li> </ol> <pre><code>// wrong type of comment # (1)!\n</code></pre> <ol> <li>According to <code>official-25</code>, this line does not contain any operators or special actions, so it is invalid; therefore, a comment.</li> </ol> <pre><code># a comment // (1)!\n</code></pre> <ol> <li>This line is a comment.</li> </ol> <pre><code>win.+ || \"Valid line\" # (1)!\n</code></pre> <ol> <li>This line is valid, as it contains a logic path with an operator; therefore, not a comment.</li> </ol>"},{"location":"language/#syntax-reference","title":"Syntax Reference","text":"<p>This is a quick reference sheet on RSML's syntax.</p> Quick syntax reference <pre><code># Logic Paths\n&lt;regex-expression&gt; &lt;operator&gt; &lt;value&gt;\nwin.+ -&gt; \"My value\"\n\n# Special Actions\n@&lt;action-name&gt; [&lt;argument&gt;]\n@MyAction MyValue\n@EndAll\n\n# Comments\n# at the start of a sentence\n# this is a comment\n\n# Spacing is flexible\nwin.+ -&gt; \"valid\"\n.+-x64          -&gt;\"valid\"\nlinux.*-&gt;     \"valid\"\nosx-arm64-&gt;\"valid\"\n</code></pre>"},{"location":"language/standards/","title":"RSML Language Standards","text":"<p>Tip</p> <p>Before proceeding, ensure you understand:</p> <ul> <li>Evaluation Process</li> <li>Language Specification</li> <li>Basic Syntax</li> </ul> <p>Since anyone can create their own RSML language standard, documenting standards is crucial for interoperability and maintenance.</p>"},{"location":"language/standards/#specifying-which-standard-is-in-use","title":"Specifying which standard is in use","text":"<p>While optional, declaring your standard helps ensure consistent interpretation. That can be done by adding a comment to your RSML file, as shown below.</p> Note <ul> <li>The declaration is purely informational - it doesn't affect parsing.</li> <li>Custom parsers may use this hint to apply correct interpretation rules.</li> <li>Case-sensitive (<code>official-25</code> \u2260 <code>Official-25</code>).</li> </ul> Specifying the standardExample 1Example 2 <pre><code># !standard: &lt;standard-name&gt; (1)\n</code></pre> <ol> <li>Must be the first line of the file.</li> </ol> <pre><code># !standard: official-25\nwin.+ -&gt; \"Primary operator\"\nlinux.+ || \"Secondary operator\"\nosx.+ ^! \"Tertiary operator\"\n</code></pre> <pre><code># !standard: roadlike\nwin.+ ??? \"Primary operator\"\nlinux.+ &lt;&lt; \"Secondary operator\"\nosx.+ !!! \"Tertiary operator\"\n</code></pre>"},{"location":"language/standards/#documenting-your-standards","title":"Documenting your standards","text":"<p>It's impossible for us to document every single standard, but we try to keep the most important ones here.</p> <p>If you'd like to document your standard, you can follow this simple guide:</p> <ol> <li>Fork the rsml-docs repository.</li> <li>Copy this file into <code>/docs/language/standards/</code>.</li> <li>Give it the name of your standard (if your standard is <code>mystand</code>, you'd name it <code>mystand.md</code>).</li> <li>Edit the file with the details of your standard.</li> <li>Make a pull request.</li> <li>After reviewing, it'll either be accepted (you can then delete your fork) or rejected, in which case you can either make changes to it and try again or... not.</li> </ol> Tip <p>As long as you just follow the template and only edit what's relevant, your PR should be accepted.</p> <p>If your standard is relevant enough, we'll do our best to add it here. However, we'd still appreciate the Pull Request.</p>"},{"location":"language/standards/official-25/","title":"Official 25","text":"<p>Name: Official 25</p> <p>ID: <code>official-25</code></p> <p>Author: OceanApocalypseStudios</p> <p>Year: 2025</p> <p>License: Unlicense</p> <p>The language standard that's closest to an official language specification. Designed in 2025 by OceanApocalypseStudios to be universal and, for the lack of a better word, standard. It's used as the main language standard in the CLI as of v1.0.1 of RSML.</p>"},{"location":"language/standards/official-25/#operators","title":"Operators","text":"<p>Official 25 defines the following tokens as operators.</p> Operator Name Operator Token Functionality Primary <code>-&gt;</code> Returns <code>val</code>. Secondary <code>||</code> Outputs <code>val</code> to the standard output (<code>stdout</code>). Tertiary <code>^!</code> Throws an error (and ends evaluation) with error message <code>val</code>."},{"location":"language/standards/official-25/#special-actions","title":"Special Actions","text":"<p>Note</p> <p><code>@EndAll</code> is built into RSML (see Special Actions).</p> <p>Official 25 does not define any special actions.</p>"},{"location":"language/standards/roadlike/","title":"Road-Like","text":"<p>Name: Road-Like</p> <p>ID: <code>roadlike</code></p> <p>Author: OceanApocalypseStudios</p> <p>Year: 2025</p> <p>License: Unlicense</p> <p>A standard made for those who wish to migrate from MFRoad to RSML. It uses MFRoad's operators, so users only need to focus on re-learning the base syntax, not the operators too.</p>"},{"location":"language/standards/roadlike/#operators","title":"Operators","text":"<p>Road-Like defines the following tokens as operators.</p> Operator Name Operator Token Functionality Primary <code>???</code> Returns <code>val</code>. Secondary <code>&lt;&lt;</code> Outputs <code>val</code> to the standard output (<code>stdout</code>). Tertiary <code>!!!</code> Throws an error (and ends evaluation) with error message <code>val</code>."},{"location":"language/standards/roadlike/#special-actions","title":"Special Actions","text":"<p>Note</p> <p><code>@EndAll</code> is built into RSML (see Special Actions).</p> <p>Road-Like does not define any special actions.</p>"}]}